// Code generated by statik. DO NOT EDIT.

// Package statik contains static assets.
package functions_statik

import (
	"github.com/rakyll/statik/fs"
)

func init() {
	data := "PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00	\x00abs.mdUT\x05\x00\x01\x80Cm8## `abs()`\n\n`abs(v instant-vector)` returns the input vector with all sample values converted to\ntheir absolute value.\nPK\x07\x08\xc6\x97\xe6\xd4w\x00\x00\x00w\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00absent.mdUT\x05\x00\x01\x80Cm8## `absent()`\n\n`absent(v instant-vector)` returns an empty vector if the vector passed to it\nhas any elements and a 1-element vector with the value 1 if the vector passed to\nit has no elements.\n\nThis is useful for alerting on when no time series exist for a given metric name\nand label combination.\n\n```\nabsent(nonexistent{job=\"myjob\"})\n# => {job=\"myjob\"}\n\nabsent(nonexistent{job=\"myjob\",instance=~\".*\"})\n# => {job=\"myjob\"}\n\nabsent(sum(nonexistent{job=\"myjob\"}))\n# => {}\n```\nPK\x07\x08\x1e\x92\xa5\x8d\xdb\x01\x00\x00\xdb\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00	\x00avg_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00ceil.mdUT\x05\x00\x01\x80Cm8## `ceil()`\n\n`ceil(v instant-vector)` rounds the sample values of all elements in `v` up to\nthe nearest integer.\nPK\x07\x08}s\xfeYq\x00\x00\x00q\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x00	\x00changes.mdUT\x05\x00\x01\x80Cm8## `changes()`\n\nFor each input time series, `changes(v range-vector)` returns the number of\ntimes its value has changed within the provided time range as an instant\nvector.\nPK\x07\x08\xff7\xa9\x93\xad\x00\x00\x00\xad\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x00	\x00clamp_max.mdUT\x05\x00\x01\x80Cm8## `clamp_max()`\n\n`clamp_max(v instant-vector, max scalar)` clamps the sample values of all\nelements in `v` to have an upper limit of `max`.\nPK\x07\x08B\x8b\xe3\x18\x8d\x00\x00\x00\x8d\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x00	\x00clamp_min.mdUT\x05\x00\x01\x80Cm8## `clamp_min()`\n\n`clamp_min(v instant-vector, min scalar)` clamps the sample values of all\nelements in `v` to have a lower limit of `min`.\nPK\x07\x08S\xc8*q\x8c\x00\x00\x00\x8c\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x12\x00	\x00count_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\x00	\x00day_in_month.mdUT\x05\x00\x01\x80Cm8## `days_in_month()`\n\n`days_in_month(v=vector(time()) instant-vector)` returns number of days in the\nmonth for each of the given times in UTC. Returned values are from 28 to 31.\nPK\x07\x08\x04\xc8\xfb\xa2\xb2\x00\x00\x00\xb2\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\x00	\x00day_of_month.mdUT\x05\x00\x01\x80Cm8## `day_of_month()`\n\n`day_of_month(v=vector(time()) instant-vector)` returns the day of the month\nfor each of the given times in UTC. Returned values are from 1 to 31.\nPK\x07\x08[\xcc\x1f\x1d\xa8\x00\x00\x00\xa8\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\x00	\x00day_of_week.mdUT\x05\x00\x01\x80Cm8## `day_of_month()`\n\n`day_of_month(v=vector(time()) instant-vector)` returns the day of the month\nfor each of the given times in UTC. Returned values are from 1 to 31.\nPK\x07\x08[\xcc\x1f\x1d\xa8\x00\x00\x00\xa8\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00delta.mdUT\x05\x00\x01\x80Cm8## `delta()`\n\n`delta(v range-vector)` calculates the difference between the\nfirst and last value of each time series element in a range vector `v`,\nreturning an instant vector with the given deltas and equivalent labels.\nThe delta is extrapolated to cover the full time range as specified in\nthe range vector selector, so that it is possible to get a non-integer\nresult even if the sample values are all integers.\n\nThe following example expression returns the difference in CPU temperature\nbetween now and 2 hours ago:\n\n```\ndelta(cpu_temp_celsius{host=\"zeus\"}[2h])\n```\n\n`delta` should only be used with gauges.\nPK\x07\x08F\xe25rc\x02\x00\x00c\x02\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00deriv.mdUT\x05\x00\x01\x80Cm8## `deriv()`\n\n`deriv(v range-vector)` calculates the per-second derivative of the time series in a range\nvector `v`, using [simple linear regression](https://en.wikipedia.org/wiki/Simple_linear_regression).\n\n`deriv` should only be used with gauges.\nPK\x07\x08ienm\xf9\x00\x00\x00\xf9\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00	\x00exp.mdUT\x05\x00\x01\x80Cm8## `exp()`\n\n`exp(v instant-vector)` calculates the exponential function for all elements in `v`.\nSpecial cases are:\n\n* `Exp(+Inf) = +Inf`\n* `Exp(NaN) = NaN`\nPK\x07\x08/\x1c\xec\x16\x9d\x00\x00\x00\x9d\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00floor.mdUT\x05\x00\x01\x80Cm8## `floor()`\n\n`floor(v instant-vector)` rounds the sample values of all elements in `v` down\nto the nearest integer.\nPK\x07\x08\x0b\xef\xe4ou\x00\x00\x00u\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x15\x00	\x00histogram_quantile.mdUT\x05\x00\x01\x80Cm8## `histogram_quantile()`\n\n`histogram_quantile(\xcf\x86 float, b instant-vector)` calculates the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86\n\xe2\x89\xa4 1) from the buckets `b` of a\n[histogram](https://prometheus.io/docs/concepts/metric_types/#histogram). (See\n[histograms and summaries](https://prometheus.io/docs/practices/histograms) for\na detailed explanation of \xcf\x86-quantiles and the usage of the histogram metric type\nin general.) The samples in `b` are the counts of observations in each bucket.\nEach sample must have a label `le` where the label value denotes the inclusive\nupper bound of the bucket. (Samples without such a label are silently ignored.)\nThe [histogram metric type](https://prometheus.io/docs/concepts/metric_types/#histogram)\nautomatically provides time series with the `_bucket` suffix and the appropriate\nlabels.\n\nUse the `rate()` function to specify the time window for the quantile\ncalculation.\n\nExample: A histogram metric is called `http_request_duration_seconds`. To\ncalculate the 90th percentile of request durations over the last 10m, use the\nfollowing expression:\n\n    histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[10m]))\n\nThe quantile is calculated for each label combination in\n`http_request_duration_seconds`. To aggregate, use the `sum()` aggregator\naround the `rate()` function. Since the `le` label is required by\n`histogram_quantile()`, it has to be included in the `by` clause. The following\nexpression aggregates the 90th percentile by `job`:\n\n    histogram_quantile(0.9, sum(rate(http_request_duration_seconds_bucket[10m])) by (job, le))\n\nTo aggregate everything, specify only the `le` label:\n\n    histogram_quantile(0.9, sum(rate(http_request_duration_seconds_bucket[10m])) by (le))\n\nThe `histogram_quantile()` function interpolates quantile values by\nassuming a linear distribution within a bucket. The highest bucket\nmust have an upper bound of `+Inf`. (Otherwise, `NaN` is returned.) If\na quantile is located in the highest bucket, the upper bound of the\nsecond highest bucket is returned. A lower limit of the lowest bucket\nis assumed to be 0 if the upper bound of that bucket is greater than\n0. In that case, the usual linear interpolation is applied within that\nbucket. Otherwise, the upper bound of the lowest bucket is returned\nfor quantiles located in the lowest bucket.\n\nIf `b` contains fewer than two buckets, `NaN` is returned. For \xcf\x86 < 0, `-Inf` is\nreturned. For \xcf\x86 > 1, `+Inf` is returned.\nPK\x07\x08\xbd\xd1\xf5\x8c\x81	\x00\x00\x81	\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\x00	\x00holt_winters.mdUT\x05\x00\x01\x80Cm8## `holt_winters()`\n\n`holt_winters(v range-vector, sf scalar, tf scalar)` produces a smoothed value\nfor time series based on the range in `v`. The lower the smoothing factor `sf`,\nthe more importance is given to old data. The higher the trend factor `tf`, the\nmore trends in the data is considered. Both `sf` and `tf` must be between 0 and\n1.\n\n`holt_winters` should only be used with gauges.\nPK\x07\x08\x87W\xb5Y\x88\x01\x00\x00\x88\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00hour.mdUT\x05\x00\x01\x80Cm8## `hour()`\n\n`hour(v=vector(time()) instant-vector)` returns the hour of the day\nfor each of the given times in UTC. Returned values are from 0 to 23.\nPK\x07\x08\xc4\xadwp\x97\x00\x00\x00\x97\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00idelta.mdUT\x05\x00\x01\x80Cm8## `idelta()`\n\n`idelta(v range-vector)`\n\n`idelta(v range-vector)` calculates the difference between the last two samples\nin the range vector `v`, returning an instant vector with the given deltas and\nequivalent labels.\n\n`idelta` should only be used with gauges.\nPK\x07\x08\xa4Z\xf9\x06\x06\x01\x00\x00\x06\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0b\x00	\x00increase.mdUT\x05\x00\x01\x80Cm8## `increase()`\n\n`increase(v range-vector)` calculates the increase in the\ntime series in the range vector. Breaks in monotonicity (such as counter\nresets due to target restarts) are automatically adjusted for. The\nincrease is extrapolated to cover the full time range as specified\nin the range vector selector, so that it is possible to get a\nnon-integer result even if a counter increases only by integer\nincrements.\n\nThe following example expression returns the number of HTTP requests as measured\nover the last 5 minutes, per time series in the range vector:\n\n```\nincrease(http_requests_total{job=\"api-server\"}[5m])\n```\n\n`increase` should only be used with counters. It is syntactic sugar\nfor `rate(v)` multiplied by the number of seconds under the specified\ntime range window, and should be used primarily for human readability.\nUse `rate` in recording rules so that increases are tracked consistently\non a per-second basis.\nPK\x07\x08.\xb1\x05\xb0\xa2\x03\x00\x00\xa2\x03\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00irate.mdUT\x05\x00\x01\x80Cm8## `irate()`\n\n`irate(v range-vector)` calculates the per-second instant rate of increase of\nthe time series in the range vector. This is based on the last two data points.\nBreaks in monotonicity (such as counter resets due to target restarts) are\nautomatically adjusted for.\n\nThe following example expression returns the per-second rate of HTTP requests\nlooking up to 5 minutes back for the two most recent data points, per time\nseries in the range vector:\n\n```\nirate(http_requests_total{job=\"api-server\"}[5m])\n```\n\n`irate` should only be used when graphing volatile, fast-moving counters.\nUse `rate` for alerts and slow-moving counters, as brief changes\nin the rate can reset the `FOR` clause and graphs consisting entirely of rare\nspikes are hard to read.\n\nNote that when combining `irate()` with an\n[aggregation operator](operators.md#aggregation-operators) (e.g. `sum()`)\nor a function aggregating over time (any function ending in `_over_time`),\nalways take a `irate()` first, then aggregate. Otherwise `irate()` cannot detect\ncounter resets when your target restarts.\nPK\x07\x08\x1fU\x8c\x8e2\x04\x00\x002\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0d\x00	\x00label_join.mdUT\x05\x00\x01\x80Cm8## `label_join()`\n\nFor each timeseries in `v`, `label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)` joins all the values of all the `src_labels`\nusing `separator` and returns the timeseries with the label `dst_label` containing the joined value.\nThere can be any number of `src_labels` in this function.\n\nThis example will return a vector with each time series having a `foo` label with the value `a,b,c` added to it:\n\n```\nlabel_join(up{job=\"api-server\",src1=\"a\",src2=\"b\",src3=\"c\"}, \"foo\", \",\", \"src1\", \"src2\", \"src3\")\n```\nPK\x07\x08\xbc\x1c9%F\x02\x00\x00F\x02\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00	\x00label_replace.mdUT\x05\x00\x01\x80Cm8## `label_replace()`\n\nFor each timeseries in `v`, `label_replace(v instant-vector, dst_label string,\nreplacement string, src_label string, regex string)` matches the regular\nexpression `regex` against the label `src_label`.  If it matches, then the\ntimeseries is returned with the label `dst_label` replaced by the expansion of\n`replacement`. `$1` is replaced with the first matching subgroup, `$2` with the\nsecond etc. If the regular expression doesn't match then the timeseries is\nreturned unchanged.\n\nThis example will return a vector with each time series having a `foo`\nlabel with the value `a` added to it:\n\n```\nlabel_replace(up{job=\"api-server\",service=\"a:c\"}, \"foo\", \"$1\", \"service\", \"(.*):.*\")\n```\nPK\x07\x08\xb4\xce\x98\n\xc3\x02\x00\x00\xc3\x02\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00	\x00ln.mdUT\x05\x00\x01\x80Cm8## `ln()`\n\n`ln(v instant-vector)` calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n\n* `ln(+Inf) = +Inf`\n* `ln(0) = -Inf`\n* `ln(x < 0) = NaN`\n* `ln(NaN) = NaN`\nPK\x07\x08\x9c\\\xeev\xbb\x00\x00\x00\xbb\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00log10.mdUT\x05\x00\x01\x80Cm8## `log10()`\n\n`log10(v instant-vector)` calculates the decimal logarithm for all elements in `v`.\nThe special cases are equivalent to those in `ln`.\nPK\x07\x08\x16\xa4\xb8+\x95\x00\x00\x00\x95\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00log2.mdUT\x05\x00\x01\x80Cm8## `log2()`\n\n`log2(v instant-vector)` calculates the binary logarithm for all elements in `v`.\nThe special cases are equivalent to those in `ln`.\nPK\x07\x082<`p\x92\x00\x00\x00\x92\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00	\x00max_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00	\x00min_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00minute.mdUT\x05\x00\x01\x80Cm8## `minute()`\n\n`minute(v=vector(time()) instant-vector)` returns the minute of the hour for each\nof the given times in UTC. Returned values are from 0 to 59.\nPK\x07\x08\xc8kd\xed\x9e\x00\x00\x00\x9e\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00month.mdUT\x05\x00\x01\x80Cm8## `month()`\n\n`month(v=vector(time()) instant-vector)` returns the month of the year for each\nof the given times in UTC. Returned values are from 1 to 12, where 1 means\nJanuary etc.\nPK\x07\x08YRN\x96\xb6\x00\x00\x00\xb6\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00	\x00predict_linear.mdUT\x05\x00\x01\x80Cm8## `predict_linear()`\n\n`predict_linear(v range-vector, t scalar)` predicts the value of time series\n`t` seconds from now, based on the range vector `v`, using [simple linear\nregression](https://en.wikipedia.org/wiki/Simple_linear_regression).\n\n`predict_linear` should only be used with gauges.\nPK\x07\x08\x92\xa7G\xe8&\x01\x00\x00&\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x15\x00	\x00quantile_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00rate.mdUT\x05\x00\x01\x80Cm8## `rate()`\n\n`rate(v range-vector)` calculates the per-second average rate of increase of the\ntime series in the range vector. Breaks in monotonicity (such as counter\nresets due to target restarts) are automatically adjusted for. Also, the\ncalculation extrapolates to the ends of the time range, allowing for missed\nscrapes or imperfect alignment of scrape cycles with the range's time period.\n\nThe following example expression returns the per-second rate of HTTP requests as measured\nover the last 5 minutes, per time series in the range vector:\n\n```\nrate(http_requests_total{job=\"api-server\"}[5m])\n```\n\n`rate` should only be used with counters. It is best suited for alerting,\nand for graphing of slow-moving counters.\n\nNote that when combining `rate()` with an aggregation operator (e.g. `sum()`)\nor a function aggregating over time (any function ending in `_over_time`),\nalways take a `rate()` first, then aggregate. Otherwise `rate()` cannot detect\ncounter resets when your target restarts.\nPK\x07\x08\xd9\xbco\xdc\xe4\x03\x00\x00\xe4\x03\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00resets.mdUT\x05\x00\x01\x80Cm8## `resets()`\n\nFor each input time series, `resets(v range-vector)` returns the number of\ncounter resets within the provided time range as an instant vector. Any\ndecrease in the value between two consecutive samples is interpreted as a\ncounter reset.\n\n`resets` should only be used with counters.\nPK\x07\x08\xc1\x86\xfe\xb2(\x01\x00\x00(\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00	\x00round.mdUT\x05\x00\x01\x80Cm8## `round()`\n\n`round(v instant-vector, to_nearest=1 scalar)` rounds the sample values of all\nelements in `v` to the nearest integer. Ties are resolved by rounding up. The\noptional `to_nearest` argument allows specifying the nearest multiple to which\nthe sample values should be rounded. This multiple may also be a fraction.\nPK\x07\x08k!\n\x01E\x01\x00\x00E\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00scalar.mdUT\x05\x00\x01\x80Cm8## `scalar()`\n\nGiven a single-element input vector, `scalar(v instant-vector)` returns the\nsample value of that single element as a scalar. If the input vector does not\nhave exactly one element, `scalar` will return `NaN`.\nPK\x07\x08?\xe3\x14\x08\xdf\x00\x00\x00\xdf\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00sort.mdUT\x05\x00\x01\x80Cm8## `sort()`\n\n`sort(v instant-vector)` returns vector elements sorted by their sample values,\nin ascending order.\nPK\x07\x08\xd1\xa3\xad\x92q\x00\x00\x00q\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x00	\x00sort_desc.mdUT\x05\x00\x01\x80Cm8## `sort_desc()`\n\nSame as `sort`, but sorts in descending order.\nPK\x07\x089\xed\xa7\x95A\x00\x00\x00A\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00sqrt.mdUT\x05\x00\x01\x80Cm8## `sqrt()`\n\n`sqrt(v instant-vector)` calculates the square root of all elements in `v`.\nPK\x07\x08d\xc3\x92\xf3Y\x00\x00\x00Y\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x13\x00	\x00stddev_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x13\x00	\x00stdvar_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00	\x00sum_over_time.mdUT\x05\x00\x01\x80Cm8## `<aggregation>_over_time()`\n\nThe following functions allow aggregating each series of a given range vector\nover time and return an instant vector with per-series aggregation results:\n\n* `avg_over_time(range-vector)`: the average value of all points in the specified interval.\n* `min_over_time(range-vector)`: the minimum value of all points in the specified interval.\n* `max_over_time(range-vector)`: the maximum value of all points in the specified interval.\n* `sum_over_time(range-vector)`: the sum of all values in the specified interval.\n* `count_over_time(range-vector)`: the count of all values in the specified interval.\n* `quantile_over_time(scalar, range-vector)`: the \xcf\x86-quantile (0 \xe2\x89\xa4 \xcf\x86 \xe2\x89\xa4 1) of the values in the specified interval.\n* `stddev_over_time(range-vector)`: the population standard deviation of the values in the specified interval.\n* `stdvar_over_time(range-vector)`: the population standard variance of the values in the specified interval.\n\nNote that all values in the specified interval have the same weight in the\naggregation even if the values are not equally spaced throughout the interval.\nPK\x07\x08\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00time.mdUT\x05\x00\x01\x80Cm8## `time()`\n\n`time()` returns the number of seconds since January 1, 1970 UTC. Note that\nthis does not actually return the current time, but the time at which the\nexpression is to be evaluated.\nPK\x07\x08\xfb\xc0w\xfc\xc2\x00\x00\x00\xc2\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x00	\x00timestamp.mdUT\x05\x00\x01\x80Cm8## `timestamp()`\n\n`timestamp(v instant-vector)` returns the timestamp of each of the samples of\nthe given vector as the number of seconds since January 1, 1970 UTC.\n\n*This function was added in Prometheus 2.0*\nPK\x07\x08@\x88\xbb\xe6\xd2\x00\x00\x00\xd2\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00	\x00	\x00vector.mdUT\x05\x00\x01\x80Cm8## `vector()`\n\n`vector(s scalar)` returns the scalar `s` as a vector with no labels.PK\x07\x08aYv\xd6T\x00\x00\x00T\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\x00\x00!(\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00	\x00year.mdUT\x05\x00\x01\x80Cm8## `year()`\n\n`year(v=vector(time()) instant-vector)` returns the year\nfor each of the given times in UTC.\nPK\x07\x08W\x04\x94vj\x00\x00\x00j\x00\x00\x00PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xc6\x97\xe6\xd4w\x00\x00\x00w\x00\x00\x00\x06\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x00\x00\x00\x00abs.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x1e\x92\xa5\x8d\xdb\x01\x00\x00\xdb\x01\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xb4\x00\x00\x00absent.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x10\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xcf\x02\x00\x00avg_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(}s\xfeYq\x00\x00\x00q\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81}\x07\x00\x00ceil.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xff7\xa9\x93\xad\x00\x00\x00\xad\x00\x00\x00\n\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81,\x08\x00\x00changes.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(B\x8b\xe3\x18\x8d\x00\x00\x00\x8d\x00\x00\x00\x0c\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x1a	\x00\x00clamp_max.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(S\xc8*q\x8c\x00\x00\x00\x8c\x00\x00\x00\x0c\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xea	\x00\x00clamp_min.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x12\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xb9\n\x00\x00count_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x04\xc8\xfb\xa2\xb2\x00\x00\x00\xb2\x00\x00\x00\x0f\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81i\x0f\x00\x00day_in_month.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!([\xcc\x1f\x1d\xa8\x00\x00\x00\xa8\x00\x00\x00\x0f\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81a\x10\x00\x00day_of_month.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!([\xcc\x1f\x1d\xa8\x00\x00\x00\xa8\x00\x00\x00\x0e\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81O\x11\x00\x00day_of_week.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(F\xe25rc\x02\x00\x00c\x02\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81<\x12\x00\x00delta.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(ienm\xf9\x00\x00\x00\xf9\x00\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xde\x14\x00\x00deriv.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(/\x1c\xec\x16\x9d\x00\x00\x00\x9d\x00\x00\x00\x06\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x16\x16\x00\x00exp.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x0b\xef\xe4ou\x00\x00\x00u\x00\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xf0\x16\x00\x00floor.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xbd\xd1\xf5\x8c\x81	\x00\x00\x81	\x00\x00\x15\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xa4\x17\x00\x00histogram_quantile.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x87W\xb5Y\x88\x01\x00\x00\x88\x01\x00\x00\x0f\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81q!\x00\x00holt_winters.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xc4\xadwp\x97\x00\x00\x00\x97\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81?#\x00\x00hour.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xa4Z\xf9\x06\x06\x01\x00\x00\x06\x01\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x14$\x00\x00idelta.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(.\xb1\x05\xb0\xa2\x03\x00\x00\xa2\x03\x00\x00\x0b\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81Z%\x00\x00increase.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x1fU\x8c\x8e2\x04\x00\x002\x04\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81>)\x00\x00irate.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xbc\x1c9%F\x02\x00\x00F\x02\x00\x00\x0d\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xaf-\x00\x00label_join.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xb4\xce\x98\n\xc3\x02\x00\x00\xc3\x02\x00\x00\x10\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x8190\x00\x00label_replace.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x9c\\\xeev\xbb\x00\x00\x00\xbb\x00\x00\x00\x05\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81C3\x00\x00ln.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x16\xa4\xb8+\x95\x00\x00\x00\x95\x00\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81:4\x00\x00log10.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(2<`p\x92\x00\x00\x00\x92\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x0e5\x00\x00log2.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x10\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xde5\x00\x00max_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x10\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x8c:\x00\x00min_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xc8kd\xed\x9e\x00\x00\x00\x9e\x00\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81:?\x00\x00minute.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(YRN\x96\xb6\x00\x00\x00\xb6\x00\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x18@\x00\x00month.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x92\xa7G\xe8&\x01\x00\x00&\x01\x00\x00\x11\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x0dA\x00\x00predict_linear.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x15\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81{B\x00\x00quantile_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xd9\xbco\xdc\xe4\x03\x00\x00\xe4\x03\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81.G\x00\x00rate.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xc1\x86\xfe\xb2(\x01\x00\x00(\x01\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81PK\x00\x00resets.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(k!\n\x01E\x01\x00\x00E\x01\x00\x00\x08\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xb8L\x00\x00round.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(?\xe3\x14\x08\xdf\x00\x00\x00\xdf\x00\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81<N\x00\x00scalar.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xd1\xa3\xad\x92q\x00\x00\x00q\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81[O\x00\x00sort.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(9\xed\xa7\x95A\x00\x00\x00A\x00\x00\x00\x0c\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\nP\x00\x00sort_desc.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(d\xc3\x92\xf3Y\x00\x00\x00Y\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x8eP\x00\x00sqrt.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x13\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81%Q\x00\x00stddev_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x13\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xd6U\x00\x00stdvar_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\x14\xef7\x11g\x04\x00\x00g\x04\x00\x00\x10\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x87Z\x00\x00sum_over_time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(\xfb\xc0w\xfc\xc2\x00\x00\x00\xc2\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x815_\x00\x00time.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(@\x88\xbb\xe6\xd2\x00\x00\x00\xd2\x00\x00\x00\x0c\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x815`\x00\x00timestamp.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(aYv\xd6T\x00\x00\x00T\x00\x00\x00	\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81Ja\x00\x00vector.mdUT\x05\x00\x01\x80Cm8PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\x00\x00!(W\x04\x94vj\x00\x00\x00j\x00\x00\x00\x07\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\xdea\x00\x00year.mdUT\x05\x00\x01\x80Cm8PK\x05\x06\x00\x00\x00\x00.\x00.\x00\xe9\x0b\x00\x00\x86b\x00\x00\x00\x00"
	fs.Register(data)
}
